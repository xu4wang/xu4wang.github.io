import{_ as s,o as i,c as a,R as l}from"./chunks/framework.VHr1O9iJ.js";const t="/assets/1645089866698.seoQJQBQ.png",e="/assets/1645089061542.XJG7iaEm.jpg",u=JSON.parse('{"title":"JavaScript的异步执行机制","description":"","frontmatter":{"title":"JavaScript的异步执行机制","subtitle":"关于 callback, promise, await, asyc, libuv, epoll等","date":"2022-02-12T00:00:00.000Z","author":"awis.me","header-img":"img/engine_lite.jpg","tags":["Node","JavaScript"]},"headers":[],"relativePath":"posts/2022-02-12-node-sync.md","filePath":"posts/2022-02-12-node-sync.md"}'),n={name:"posts/2022-02-12-node-sync.md"},p=l(`<h1 id="javascript的异步执行机制" tabindex="-1">JavaScript的异步执行机制 <a class="header-anchor" href="#javascript的异步执行机制" aria-label="Permalink to &quot;JavaScript的异步执行机制&quot;">​</a></h1><blockquote><p>回顾：</p><ul><li>JavaScript语言定义的 callback, promise, await, asyc</li><li>JavaScript/NodeJS 引擎（libuv）</li><li>操作系统IO多路复用（epoll）.</li></ul><p>了解 JavaScript 异步函数的运行和实现机制，方便阅读和调试JavaScript代码。</p></blockquote><h2 id="_1-简介" tabindex="-1">1. 简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1. 简介&quot;">​</a></h2><p>对于习惯了线程池/多进程/消息队列的程序员，使用JavaScript/NodeJS，有几个概念需要了解。</p><ul><li>Callbacks, Promises, Async Await</li><li>IO多路复用和异步访问</li></ul><h2 id="_2-callbacks-promises-async-await" tabindex="-1">2. Callbacks, Promises, Async Await <a class="header-anchor" href="#_2-callbacks-promises-async-await" aria-label="Permalink to &quot;2. Callbacks, Promises, Async Await&quot;">​</a></h2><p>Youtube有个视频<a href="https://www.youtube.com/watch?v=PoRJizFvM7s&amp;list=PLz-wA1QEiaA4bqejYQGjfhHhqc21CYV0w&amp;index=4" target="_blank" rel="noreferrer">Async JS Crash Course - Callbacks, Promises, Async Await</a>, 用24分钟把这几个概念演示的很清楚。</p><p>Callback是最基本的，但是Callback有一个问题，在写异步函数的时候，需要把callbank函数作为参数传进去。 如果这个函数本身是个异步函数，它也有一个callback函数作为参数。如果层数很多，就产生了callback hell。 函数可读性很差。</p><p>为了解决这个问题， Promise引入了一层封装， 在定义异步函数时候不需要指明callback函数了。 可以在Promise定义后再：</p><ul><li>通过then来定义执行成功后的回调</li><li>通过catch定义执行异常情况下的回调</li></ul><p>Async Await是对Promise的进一步封装。让异步函数看起来象同步函数（不再需要Promose里面的then来显式定义回调）。</p><p>下面抄自<a href="https://developers.google.com/web/fundamentals/primers/async-functions" target="_blank" rel="noreferrer">google官方文档</a></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFirstAsyncFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fulfilledValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promise;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (rejectedValue) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // …</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>如果在函数定义之前使用了 async 关键字，就可以在函数内使用 await。 当您 await 某个 Promise 时，函数暂停执行，直至该 Promise 产生结果，并且暂停并不会阻塞主线程。 如果 Promise 执行，则会返回值。 如果 Promise 拒绝，则会抛出拒绝的值。</p></blockquote><p>JavaScript程序在执行时候， 先逐行同步执行每一条语句。 当碰到callback时候，把该callback放入队列中，继续执行下一条语句,所有语句执行完之后，再看队列里面有哪些callback具备执行条件了，一一执行。参见后面的NodeJS Event Loop。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  doB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  doC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  doE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>以上执行顺序是：A，F，B，C，E，D。 以上ABCDEF都没有外部事件的依赖，当函数是某一个异步函数的callback时候，其是否执行还取决于该callback对应的事件是不是发生了。</p><p>例如：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 请等三秒钟!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;changeState()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> );  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;content&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    content.innerHTML</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;div style=&#39;color:red&#39;&gt;我是三秒后显示的内容！&lt;/div&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>上面changeState在时间到了后才会执行。参见后面event loop中的Timers部分描述。</p><p>以上Callback是通过setTimeout函数来配置的。setTimeout是JS引擎本身的异步函数。调用它后会立即返回，但传入的callback会在特定事件发生时候被回调。</p><p>一个JS程序中会有各种各样的回调函数，通过JS提供的定时器或者网络/文件访问函数来生效。 JS内部的回调函数实现用到了IO多路复用和异步访问机制。</p><h2 id="_3-io多路复用和异步访问" tabindex="-1">3. IO多路复用和异步访问 <a class="header-anchor" href="#_3-io多路复用和异步访问" aria-label="Permalink to &quot;3. IO多路复用和异步访问&quot;">​</a></h2><p>IO多路复用（事件驱动IO）不是JavaScript/NodeJS的独创， 是一种通用的IO访问模式。高性能的web服务器大多数采用这种模式（例如nginx）。</p><p>JavaScript以IO异步访问出名，原因是它只支持这种IO方式。强迫程序员用这种不是那么友好，但在IO密集型应用中性能好的设计模式。</p><p>Python也支持异步IO方式，但由于历史原因，大多数应用采用多进程/多线程方式，在进程内部同步处理IO。</p><p>libevent，libev，libuv 都是开发IO多路复用应用的第三方库，其主要功能是屏蔽不同操作系统API的差异，给应用提供统一接口。</p><p>libevent/libev/libuv 等在网络服务器应用上，能支撑大的并发连接数。原因在于它可以在有限的内存消耗下，把对成千上万个IO的状态扫描工作交给操作系统完成。 对于新的网络请求：</p><ul><li>不需要新的进程/线程进行处理，减少资源消耗</li><li>不需要应用层增加异步轮询的处理时间，epoll_ctl 告诉OS就OK了。</li></ul><p>浏览器中的JS和后端的NodeJS都有异步机制。 其本质都是在操作系统的进程中（Chrome进程或者NodeJS进程）访问操作系统提供的异步IO API来实现。 以下以NodeJS为主要分析对象。</p><p>NodeJS使用libuv来实现IO多路复用和异步IO。 libuv本来是NodeJS项目的产物，由于比较成功，也被其它项目使用了，例如Python生态环境的web framework <a href="https://fastapi.tiangolo.com/" target="_blank" rel="noreferrer">Fastapi</a>也使用了libuv。</p><blockquote><p>备注</p><p><a href="https://www.4e00.com/blog/linux/2017/09/29/unix-network-programming-charpter-6-io-multiplexing.html" target="_blank" rel="noreferrer">《UNP: Unix Network Programming》</a> 中把访问IO的方式分成了5种：</p><ul><li>blocking I/O</li><li>nonblocking I/O</li><li>I/O multiplexing (select and poll)</li><li>signal driven I/O (SIGIO)</li><li>asynchronous I/O (the POSIX aio_ functions)</li></ul><p>其中第三类，libuv用的epoll就是在select/poll基础上发展出来的增强版poll。</p><p>UNP中的第五类也叫异步IO，特指由操作系统负责IO数据读写，应用不关心读写，只关心读写完成事件（类似DMA）。</p><p>这点和JavaScript中的异步IO有区别。JavaScript中的异步IO更精确说是指的IO多路复用下的非阻塞IO。</p></blockquote><h3 id="_3-1-nodejs的event-loop" tabindex="-1">3.1. NodeJS的event loop <a class="header-anchor" href="#_3-1-nodejs的event-loop" aria-label="Permalink to &quot;3.1. NodeJS的event loop&quot;">​</a></h3><p><img src="`+t+'" alt="picture 2"></p><ul><li>timers: this phase executes callbacks scheduled by setTimeout() and setInterval().</li><li>pending callbacks: executes I/O callbacks deferred to the next loop iteration.</li><li>idle, prepare: only used internally.</li><li>poll: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); node will block here when appropriate.</li><li>check: setImmediate() callbacks are invoked here.</li><li>close callbacks: some close callbacks, e.g. socket.on(&#39;close&#39;, ...).</li></ul><p><a href="https://NodeJS.org/uk/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noreferrer">NodeJS官方文档</a>中可以看到，event loop里面，主线程在不断的poll（在linux下就是通过libuv调用epoll_wait，来查看有哪些事件发生了。然后调用对应的用户注册的各种callback。</p><h3 id="_3-2-libuv" tabindex="-1">3.2. libuv <a class="header-anchor" href="#_3-2-libuv" aria-label="Permalink to &quot;3.2. libuv&quot;">​</a></h3><p><a href="https://NodeJS.org/en/docs/meta/topics/dependencies/#libuv" target="_blank" rel="noreferrer">文档中对libuv有如下介绍</a>：</p><blockquote><p>Another important dependency is libuv, a C library that is used to abstract non-blocking I/O operations to a consistent interface across all supported platforms. It provides mechanisms to handle file system, DNS, network, child processes, pipes, signal handling, polling and streaming. It also includes a thread pool for offloading work for some things that can&#39;t be done asynchronously at the operating system level.</p></blockquote><p><img src="'+e+`" alt="picture 1"><br> 可见在<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noreferrer">libuv</a>中：</p><ul><li>网络IO：使用操作系统提供的异步IO实现。</li><li>文件读写等：使用线程池封装出异步事件接口。</li></ul><h3 id="_3-3-网络io中的os调用" tabindex="-1">3.3. 网络IO中的OS调用 <a class="header-anchor" href="#_3-3-网络io中的os调用" aria-label="Permalink to &quot;3.3. 网络IO中的OS调用&quot;">​</a></h3><p>对于网络数据收发， libuv针对不同操作系统做了封装。在linux下使用异步IO API epoll，epoll提供三个API：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epoll_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epoll_ctl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> epfd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> fd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> epoll_event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epoll_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> epfd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> epoll_event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">events</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> maxevents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>应用程序通过epoll_ctl来配置需要听哪些事件，通过epoll_wait来查询当前时间有哪些感兴趣的事件已经发生了。</p><blockquote><p>注意：</p><ul><li>epoll_ctl 可配置的事件有文件描述符可读，可写等。</li><li>epoll_wait 不一定会阻塞，timeout参数可以使用一个很短的时间，达到查一下事件然后立即返回的目的。 NodeJS就是这样的。如果一直wait，event loop就转不起来了。</li></ul></blockquote><h2 id="_4-总结" tabindex="-1">4. 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4. 总结&quot;">​</a></h2><p>JavaScript使用异步方式访问IO，为了程序的可读性，在callback的基础上做了若干封装。 Async Await看起来已经和同步函数很相近了。</p><p>JavaScript的异步事件，是由操作系统底层支持的。事件的产生由操作系统底层触发，由JavaScript内部事件循环来读取事件，并调用相应的事件处理Callback。</p><p>JavaScript代码没办法自主生成事件。 JavaScript的异步函数是对引擎API中需要的callback的实现，以及对引擎API的进一步封装。</p>`,50),h=[p];function k(r,o,c,d,E,g){return i(),a("div",null,h)}const b=s(n,[["render",k]]);export{u as __pageData,b as default};
