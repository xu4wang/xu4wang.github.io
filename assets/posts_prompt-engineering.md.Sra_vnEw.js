import { _ as _export_sfc, o as openBlock, c as createElementBlock, V as createStaticVNode } from "./chunks/framework.XmXKRmb4.js";
const _imports_0 = "/assets/1702655347861.RXd37daG.jpeg";
const __pageData = JSON.parse('{"title":"OpenAI Prompt Engineering","description":"","frontmatter":{"date":"2023-12-27T00:00:00.000Z","title":"OpenAI Prompt Engineering","tags":["AI"]},"headers":[],"relativePath":"posts/prompt-engineering.md","filePath":"posts/prompt-engineering.md"}');
const _sfc_main = { name: "posts/prompt-engineering.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="_1-摘要" tabindex="-1">1. 摘要 <a class="header-anchor" href="#_1-摘要" aria-label="Permalink to &quot;1. 摘要&quot;">​</a></h2><p>Prompt Engineering，即提示工程，是一种在人工智能（特别是自然语言处理和生成领域）中设计和优化输入提示（prompt）以获得期望输出的技术。</p><p>OpenAI在其公开的文档中，给出了优化提示词的6个策略，其中前5个对普通用户使用AI有帮助。下表单击TAB查看每个策略的细节和例子。</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-QFhSK" id="tab-8AnOFER" checked="checked"><label for="tab-8AnOFER">写清晰的指令</label><input type="radio" name="group-QFhSK" id="tab-4lyYnKe"><label for="tab-4lyYnKe">提供参考文本</label><input type="radio" name="group-QFhSK" id="tab-K-Q-cDi"><label for="tab-K-Q-cDi">将复杂任务分解为简单子任务</label><input type="radio" name="group-QFhSK" id="tab-LgcILZ5"><label for="tab-LgcILZ5">给模型时间“思考”</label><input type="radio" name="group-QFhSK" id="tab-AfTTTQe"><label for="tab-AfTTTQe">使用外部工具</label><input type="radio" name="group-QFhSK" id="tab-uwuuomE"><label for="tab-uwuuomE">系统地测试更改</label></div><div class="blocks"><div class="language-markdown vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 在查询中包含细节以获得更相关的答案</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：要求模型写一篇关于气候变化的文章，提供具体细节如期望的长度和主题的特定方面</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 要求模型采用特定角色</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：指示模型扮演一名经济学家，回答有关市场趋势的问题</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用分隔符清晰指示输入的不同部分</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：用引号分隔不同的问题部分，以便模型能够区分和准确回答</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 明确指定完成任务所需的步骤</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：详细列出解决数学问题的步骤要求，指导模型逐步解答</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 提供例子</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：给模型展示一个良好的邮件格式，要求模仿该格式撰写邮件</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 指定输出的期望长度</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：指定生成的故事应该包含大约500个单词</span></span></code></pre></div><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 指示模型使用参考文本来回答</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：提供一篇科学论文，让模型根据论文内容回答相关问题</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 指示模型使用参考文本中的引用来回答</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：要求模型在回答问题时，使用提供的参考书目中的引用</span></span></code></pre></div><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用意图分类来识别用户查询中最相关的指令</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：分析用户的查询，识别出最相关的搜索意图并针对性地回答</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 对于需要非常长对话的对话应用程序，概括或过滤以前的对话</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：在长时间的聊天中，总结之前的对话内容，仅回答最关键的问题</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 分段概括长文档，并递归构建完整概括</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：分章节概括一本书的内容，然后整合成完整的摘要</span></span></code></pre></div><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 指示模型在急于得出结论之前先计算出自己的解决方案</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：要求模型先推理出数学问题的解决方法，然后再给出答案</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用内部独白或一系列查询来隐藏模型的推理过程</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：通过一系列的问题引导模型深入思考问题，然后综合回答</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 询问模型是否在之前的回合中错过了什么</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：在多轮对话后，要求模型回顾并补充可能遗漏的重要信息</span></span></code></pre></div><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用基于嵌入式搜索实现高效的知识检索</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：结合搜索引擎功能，为特定查询提供最相关的信息</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用代码执行进行更准确的计算或调用外部API</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：利用代码执行工具计算复杂的数学公式或访问特定API获取数据</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 给模型提供特定功能的访问权限</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：让模型能够调用特定的外部函数或服务以增强其功能</span></span></code></pre></div><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 以参考标准答案评估模型输出</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    例如：用一组标准答案来测试模型的性能，确保其准确性和可靠性</span></span></code></pre></div></div></div><h2 id="_2-openai-prompt-engineering" tabindex="-1">2. OpenAI Prompt Engineering <a class="header-anchor" href="#_2-openai-prompt-engineering" aria-label="Permalink to &quot;2. OpenAI Prompt Engineering&quot;">​</a></h2><h3 id="_2-1-写清晰的指令-write-clear-instructions" tabindex="-1">2.1. 写清晰的指令 / Write clear instructions <a class="header-anchor" href="#_2-1-写清晰的指令-write-clear-instructions" aria-label="Permalink to &quot;2.1. 写清晰的指令 / Write clear instructions&quot;">​</a></h3><h4 id="_2-1-1-在查询中包含细节以获得更相关的答案" tabindex="-1">2.1.1. 在查询中包含细节以获得更相关的答案 <a class="header-anchor" href="#_2-1-1-在查询中包含细节以获得更相关的答案" aria-label="Permalink to &quot;2.1.1. 在查询中包含细节以获得更相关的答案&quot;">​</a></h4><p>“用一个段落总结会议记录。然后写下演讲者的 Markdown 列表以及他们的每个要点。最后，列出发言人建议的后续步骤或行动项目（如果有）。”</p><h4 id="_2-1-2-要求模型采用特定角色" tabindex="-1">2.1.2. 要求模型采用特定角色 <a class="header-anchor" href="#_2-1-2-要求模型采用特定角色" aria-label="Permalink to &quot;2.1.2. 要求模型采用特定角色&quot;">​</a></h4><p>充当一个喜欢讲笑话的喜剧演员，每当我当我请求帮助写一些东西时，你会回复一份文档，其中每个段落至少包含一个笑话或有趣的评论。</p><h4 id="_2-1-3-使用分隔符清晰指示输入的不同部分" tabindex="-1">2.1.3. 使用分隔符清晰指示输入的不同部分 <a class="header-anchor" href="#_2-1-3-使用分隔符清晰指示输入的不同部分" aria-label="Permalink to &quot;2.1.3. 使用分隔符清晰指示输入的不同部分&quot;">​</a></h4><p>用50个字符总结由三引号分隔的文本。&quot;&quot;&quot;在此插入文字&quot;&quot;&quot;</p><h4 id="_2-1-4-明确指定完成任务所需的步骤" tabindex="-1">2.1.4. 明确指定完成任务所需的步骤 <a class="header-anchor" href="#_2-1-4-明确指定完成任务所需的步骤" aria-label="Permalink to &quot;2.1.4. 明确指定完成任务所需的步骤&quot;">​</a></h4><p>使用以下分步说明来响应用户输入。 步骤1 - 用户将为您提供三引号中的文本。用一个句子总结这段文字，并加上前缀“Summary:”。 步骤2 - 将步骤1中的摘要翻译成西班牙语，并添加前缀“翻译：”。</p><h4 id="_2-1-5-提供例子" tabindex="-1">2.1.5. 提供例子 <a class="header-anchor" href="#_2-1-5-提供例子" aria-label="Permalink to &quot;2.1.5. 提供例子&quot;">​</a></h4><p>按这句话的风格来写XX文章：&quot;&quot;&quot;落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨&quot;&quot;&quot;</p><h4 id="_2-1-6-指定输出的期望长度" tabindex="-1">2.1.6. 指定输出的期望长度 <a class="header-anchor" href="#_2-1-6-指定输出的期望长度" aria-label="Permalink to &quot;2.1.6. 指定输出的期望长度&quot;">​</a></h4><p>用两个段落、100个字符概括由三引号分隔的文本。&quot;&quot;&quot;在此插入文字&quot;&quot;&quot;</p><h3 id="_2-2-提供参考文本-provide-reference-text" tabindex="-1">2.2. 提供参考文本 / Provide reference text <a class="header-anchor" href="#_2-2-提供参考文本-provide-reference-text" aria-label="Permalink to &quot;2.2. 提供参考文本 / Provide reference text&quot;">​</a></h3><h4 id="_2-2-1-指示模型使用参考文本来回答" tabindex="-1">2.2.1. 指示模型使用参考文本来回答 <a class="header-anchor" href="#_2-2-1-指示模型使用参考文本来回答" aria-label="Permalink to &quot;2.2.1. 指示模型使用参考文本来回答&quot;">​</a></h4><p>使用提供的由三重引号引起来的文章来回答问题。如果在文章中找不到答案，请写“我找不到答案”。 &quot;&quot;&quot;&lt;在此插入文档&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;在此插入文档&gt;&quot;&quot;&quot; 问题：&lt;在此插入问题&gt;</p><h4 id="_2-2-2-指示模型使用参考文本中的引用来回答" tabindex="-1">2.2.2. 指示模型使用参考文本中的引用来回答 <a class="header-anchor" href="#_2-2-2-指示模型使用参考文本中的引用来回答" aria-label="Permalink to &quot;2.2.2. 指示模型使用参考文本中的引用来回答&quot;">​</a></h4><p>您将获得一份由三重引号和一个问题分隔的文档。您的任务是仅使用提供的文档回答问题，并引用用于回答问题的文档段落。如果文档不包含回答此问题所需的信息，则只需写：“信息不足”。如果提供了问题的答案，则必须附有引文注释。使用以下格式引用相关段落（{“引用”：…}）。</p><p>&quot;&quot;&quot;&lt;在此插入文档&gt;&quot;&quot;&quot;</p><p>问题：&lt;在此插入问题&gt;</p><h3 id="_2-3-将复杂任务分解为简单子任务-split-complex-tasks-into-simpler-subtasks" tabindex="-1">2.3. 将复杂任务分解为简单子任务 / Split complex tasks into simpler subtasks <a class="header-anchor" href="#_2-3-将复杂任务分解为简单子任务-split-complex-tasks-into-simpler-subtasks" aria-label="Permalink to &quot;2.3. 将复杂任务分解为简单子任务 / Split complex tasks into simpler subtasks&quot;">​</a></h3><h4 id="_2-3-1-使用意图分类来识别用户查询中最相关的指令" tabindex="-1">2.3.1. 使用意图分类来识别用户查询中最相关的指令 <a class="header-anchor" href="#_2-3-1-使用意图分类来识别用户查询中最相关的指令" aria-label="Permalink to &quot;2.3.1. 使用意图分类来识别用户查询中最相关的指令&quot;">​</a></h4><p>预先给AI设定一个问题搜索树。让AI对收到的问题，根据搜索树来解决。</p><h4 id="_2-3-2-对于需要非常长对话的对话应用程序-概括或过滤以前的对话" tabindex="-1">2.3.2. 对于需要非常长对话的对话应用程序，概括或过滤以前的对话 <a class="header-anchor" href="#_2-3-2-对于需要非常长对话的对话应用程序-概括或过滤以前的对话" aria-label="Permalink to &quot;2.3.2. 对于需要非常长对话的对话应用程序，概括或过滤以前的对话&quot;">​</a></h4><p>因为模型具有固定的上下文长度，因此用户和助手之间的对话无法无限期地继续。 解决此问题可以总结历史对话。一旦输入的大小达到预定的阈值长度，将总结作为系统消息的一部分包括在内。</p><h4 id="_2-3-3-分段概括长文档-并递归构建完整概括" tabindex="-1">2.3.3. 分段概括长文档，并递归构建完整概括 <a class="header-anchor" href="#_2-3-3-分段概括长文档-并递归构建完整概括" aria-label="Permalink to &quot;2.3.3. 分段概括长文档，并递归构建完整概括&quot;">​</a></h4><p>长文档受Token长度限制，无法一次总结。可以章节输入。章节摘要可以连接和总结，生成摘要的摘要。 摘要的摘要也可以再总结。 递归完成对超长文档的总结。</p><h3 id="_2-4-给模型时间-思考-give-the-model-time-to-think" tabindex="-1">2.4. 给模型时间“思考” / Give the model time to &quot;think&quot; <a class="header-anchor" href="#_2-4-给模型时间-思考-give-the-model-time-to-think" aria-label="Permalink to &quot;2.4. 给模型时间“思考” / Give the model time to &quot;think&quot;&quot;">​</a></h3><h4 id="_2-4-1-指示模型在急于得出结论之前先计算出自己的解决方案" tabindex="-1">2.4.1. 指示模型在急于得出结论之前先计算出自己的解决方案 <a class="header-anchor" href="#_2-4-1-指示模型在急于得出结论之前先计算出自己的解决方案" aria-label="Permalink to &quot;2.4.1. 指示模型在急于得出结论之前先计算出自己的解决方案&quot;">​</a></h4><p>比如你扔个数学题给大模型，你让他判断对或者不对，你会发现结果很随机，一会对或者不对，但是如果你先让他自己做一遍，再去判断对与不对，结果就会准非常多了。</p><p>比如你可以说：首先制定自己的问题解决方案。然后将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。在你自己完成问题之前，不要决定学生的解决方案是否正确。</p><h4 id="_2-4-2-使用内部独白或一系列查询来隐藏模型的推理过程" tabindex="-1">2.4.2. 使用内部独白或一系列查询来隐藏模型的推理过程 <a class="header-anchor" href="#_2-4-2-使用内部独白或一系列查询来隐藏模型的推理过程" aria-label="Permalink to &quot;2.4.2. 使用内部独白或一系列查询来隐藏模型的推理过程&quot;">​</a></h4><p>本质还是一步一步分布推理。 用独白是为了隐藏对外输出的信息。</p><h4 id="_2-4-3-询问模型是否在之前的回合中错过了什么" tabindex="-1">2.4.3. 询问模型是否在之前的回合中错过了什么 <a class="header-anchor" href="#_2-4-3-询问模型是否在之前的回合中错过了什么" aria-label="Permalink to &quot;2.4.3. 询问模型是否在之前的回合中错过了什么&quot;">​</a></h4><p>比如我让他根据我的文档，给我列出这个问题在文档中的相关片段：“北京烤鸭到底好吃在哪”，然后让他用JSON格式输出</p><p>{&quot;相关片段&quot;：&quot;...&quot;}，</p><p>在输出停止以后，我们可以再问一句：</p><p>还有更多相关片段吗？注意不要重复摘录。还要确保相关片段包含解释它们所需的所有相关上下文 - 换句话说，不要提取缺少重要上下文的小片段。</p><p>“Are there more relevant excerpts? Take care not to repeat excerpts. Also ensure that excerpts contain all relevant context needed to interpret them - in other words don&#39;t extract small snippets that are missing important context.”</p><h3 id="_2-5-使用外部工具-use-external-tools" tabindex="-1">2.5. 使用外部工具 / Use external tools <a class="header-anchor" href="#_2-5-使用外部工具-use-external-tools" aria-label="Permalink to &quot;2.5. 使用外部工具 / Use external tools&quot;">​</a></h3><h4 id="_2-5-1-使用基于嵌入式搜索实现高效的知识检索" tabindex="-1">2.5.1. 使用基于嵌入式搜索实现高效的知识检索 <a class="header-anchor" href="#_2-5-1-使用基于嵌入式搜索实现高效的知识检索" aria-label="Permalink to &quot;2.5.1. 使用基于嵌入式搜索实现高效的知识检索&quot;">​</a></h4><p>这个是使用RAG，Retrieval Augmented Generation， 在给AI的提问中预先准备好相关知识。 例如：</p><p>加载文件 -&gt; 读取文本 -&gt; 文本分割 -&gt; 文本向量化 -&gt; 问句向量化 -&gt; 在文本向量中匹配出与问句向量最相似的top k个 -&gt; 匹配出的文本作为上下文和问题一起添加到prompt中 -&gt; 提交给大模型生成回答。</p><h4 id="_2-5-2-使用代码执行进行更准确的计算或调用外部api" tabindex="-1">2.5.2. 使用代码执行进行更准确的计算或调用外部API <a class="header-anchor" href="#_2-5-2-使用代码执行进行更准确的计算或调用外部api" aria-label="Permalink to &quot;2.5.2. 使用代码执行进行更准确的计算或调用外部API&quot;">​</a></h4><p>两种场景：</p><ol><li>让AI写代码</li><li>给AI提供API，使用function calling。</li></ol><h4 id="_2-5-3-给模型提供特定功能的访问权限" tabindex="-1">2.5.3. 给模型提供特定功能的访问权限 <a class="header-anchor" href="#_2-5-3-给模型提供特定功能的访问权限" aria-label="Permalink to &quot;2.5.3. 给模型提供特定功能的访问权限&quot;">​</a></h4><p>给AI一堆API定义。 让AI根据问题选择该去调用哪个API。 再将AI的选择实际执行后得到的输出喂给AI来加工成人可以读懂的输出。</p><h3 id="_2-6-系统地测试更改-test-changes-systematically" tabindex="-1">2.6. 系统地测试更改 / Test changes systematically <a class="header-anchor" href="#_2-6-系统地测试更改-test-changes-systematically" aria-label="Permalink to &quot;2.6. 系统地测试更改 / Test changes systematically&quot;">​</a></h3><h4 id="_2-6-1-以参考标准答案评估模型输出" tabindex="-1">2.6.1. 以参考标准答案评估模型输出 <a class="header-anchor" href="#_2-6-1-以参考标准答案评估模型输出" aria-label="Permalink to &quot;2.6.1. 以参考标准答案评估模型输出&quot;">​</a></h4><p>可以忽略。 评估AI性能用。</p><h2 id="_3-参考" tabindex="-1">3. 参考 <a class="header-anchor" href="#_3-参考" aria-label="Permalink to &quot;3. 参考&quot;">​</a></h2><ol><li><p>From <a href="https://www.linkedin.com/in/eric-vyacheslav-156273169/" target="_blank" rel="noreferrer">https://www.linkedin.com/in/eric-vyacheslav-156273169/</a><img src="' + _imports_0 + '" alt="Alt text"></p></li><li><p><a href="https://platform.openai.com/docs/guides/prompt-engineering" target="_blank" rel="noreferrer">https://platform.openai.com/docs/guides/prompt-engineering</a></p></li></ol>', 58);
const _hoisted_59 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_59);
}
const promptEngineering = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  promptEngineering as default
};
